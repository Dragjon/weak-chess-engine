// error 0.0762988

#include <stdint.h>

#include "chess.hpp"
#include "packing.hpp"
#include "eval.hpp"
#include "defaults.hpp"
#include "bitboard.hpp"

using namespace chess;
using namespace std;

// Entire evaluation function is tuned with non other than Gedas' Texel tuner <3
// https://github.com/GediminasMasaitis/texel-tuner
// Data is self-generated by rescoring lichess-big3 with Weak's search

/////////////////////////////////
// HCE Evaluation description ///
/////////////////////////////////

// 1. 
// PST
// Piece Square Tables (which includes the material value of each piece)
// Each piece type has its own piece square table, whiched it used
// to evaluate its positioning on the board

// 2. 
// Mobility Eval
// Each piece type can attack at most 28 squares in any given turn. In
// general, the more squares a piece attacks the better. But for example
// pieces like queens may get negative mobility in the opening to prevent
// early queen moves. The 4th index (index 5) of the mobilities array is 
// dedicated to king virtual mobility. That is putting a queen on a king sq
// and getting the mobility of the queen from there. This helps to position
// the king away from open rays

// 3.
// Bishop pair evaluation
// Bishop pair eval is a pretty good eval heuristic for HCE engines and is
// pretty intuitive to implement.

// 4.
// Passed pawn bonus
// Passed pawns are given a bonus indexed by which square they are on. Passed
// pawns that are more advanced generally have higher scores.

// 5. / 6.
// King zone attacks 
// Bonus for pieces (not pawns or kings) which attack squares near the opponent
// king. This includes the square directly surrounding the opponent king and also
// 1 square away from the king

// 7. 
// Doubled pawn penalty
// Doubled pawns are given a penalty depending on which file they are on. This is
// a pretty strong eval feature and is also easy to understand. Doubled pawns
// (NOT stacked pawns) are pawns that are on the same file. It is usually bad
// to have doubled pawns

// 8.
// Pawn storm
// Pawns on the other half of the board without the king are given a different
// bonus-table. This could encourage those pawns to move more freely and participate
// in a "pawn storm" to attack the king

// 9.
// Isolated pawns
// Isolated pawns are given a penalty depending on which square they are on. Being
// isolated is defined as pawns whose adjacent files have no other friendly pawns.

// 10.
// Threats
// Threats are attacks that are made by a friendly piece to an enemy piece. This is
// indexed by [our piece][their piece]. This could make our evaluation more accurate

// 11.
// Rook on semi open file bonus
// It is usually better for rooks to be in semi open files in the middlegame to control
// more squares

// 12.
// Pawn phalanxes
// A really simple eval term. Gives bonuses to pawns that are adjacent to each other
// and indexed by [rank]. This can be useful for endgames where connected passers 
// are really strong.

const int32_t PSQT[6][64] = {
    {
        S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0),
        S(30, 176), S(44, 193), S(52, 175), S(58, 140), S(64, 113), S(58, 121), S(31, 148), S(22, 154),
        S(42, 152), S(69, 175), S(73, 158), S(93, 133), S(96, 102), S(118, 105), S(104, 146), S(74, 122),
        S(56, 116), S(76, 126), S(73, 112), S(63, 100), S(74, 90), S(79, 88), S(67, 109), S(57, 92),
        S(50, 93), S(64, 110), S(66, 94), S(68, 99), S(59, 92), S(68, 86), S(55, 99), S(46, 77),
        S(67, 88), S(82, 102), S(71, 96), S(48, 104), S(61, 104), S(67, 96), S(74, 98), S(58, 76),
        S(63, 87), S(94, 96), S(78, 93), S(57, 102), S(55, 113), S(72, 95), S(83, 95), S(55, 73),
        S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0)
    },
    {
        S(23, 84), S(18, 141), S(50, 116), S(61, 118), S(96, 112), S(41, 102), S(65, 126), S(60, 70),
        S(77, 124), S(75, 114), S(62, 113), S(74, 117), S(69, 115), S(88, 104), S(84, 107), S(95, 118),
        S(87, 103), S(76, 108), S(120, 149), S(130, 155), S(138, 149), S(137, 143), S(78, 108), S(103, 99),
        S(99, 114), S(77, 122), S(121, 160), S(133, 165), S(124, 161), S(138, 162), S(80, 124), S(111, 112),
        S(91, 116), S(66, 119), S(107, 160), S(104, 162), S(108, 164), S(113, 154), S(79, 117), S(95, 110),
        S(79, 109), S(62, 117), S(100, 145), S(99, 159), S(110, 157), S(104, 146), S(77, 109), S(87, 108),
        S(80, 134), S(73, 113), S(53, 112), S(66, 110), S(66, 108), S(60, 110), S(79, 111), S(101, 136),
        S(74, 129), S(93, 124), S(65, 111), S(75, 108), S(76, 112), S(80, 105), S(95, 128), S(89, 126)
    },
    {
        S(75, 149), S(57, 151), S(65, 147), S(31, 152), S(49, 147), S(46, 151), S(75, 147), S(73, 144),
        S(62, 142), S(71, 147), S(73, 145), S(69, 144), S(74, 142), S(80, 143), S(65, 150), S(71, 137),
        S(86, 147), S(106, 145), S(94, 148), S(103, 142), S(97, 147), S(108, 147), S(98, 148), S(97, 149),
        S(87, 145), S(87, 152), S(95, 152), S(106, 165), S(100, 159), S(94, 155), S(94, 146), S(83, 145),
        S(88, 147), S(87, 155), S(93, 157), S(104, 161), S(99, 161), S(102, 152), S(88, 153), S(99, 140),
        S(102, 147), S(106, 157), S(104, 157), S(101, 156), S(106, 157), S(106, 155), S(110, 149), S(109, 147),
        S(112, 152), S(113, 138), S(107, 143), S(101, 146), S(105, 147), S(110, 142), S(123, 146), S(117, 137),
        S(104, 138), S(113, 140), S(107, 140), S(90, 148), S(97, 146), S(99, 151), S(105, 142), S(110, 136)
    },
    {
        S(104, 291), S(105, 289), S(101, 297), S(110, 289), S(104, 286), S(119, 283), S(113, 285), S(132, 280),
        S(110, 283), S(108, 284), S(129, 284), S(140, 277), S(129, 276), S(139, 268), S(130, 268), S(152, 262),
        S(102, 279), S(119, 274), S(115, 273), S(119, 269), S(124, 263), S(128, 259), S(153, 253), S(134, 258),
        S(104, 279), S(108, 274), S(117, 274), S(118, 268), S(114, 262), S(123, 259), S(119, 261), S(123, 259),
        S(97, 280), S(92, 278), S(101, 278), S(107, 275), S(106, 270), S(107, 265), S(109, 261), S(114, 261),
        S(100, 278), S(98, 275), S(104, 275), S(109, 272), S(112, 267), S(118, 262), S(130, 251), S(121, 256),
        S(101, 276), S(102, 274), S(113, 275), S(116, 273), S(119, 266), S(118, 263), S(131, 253), S(111, 263),
        S(128, 275), S(121, 273), S(124, 275), S(131, 270), S(129, 266), S(125, 266), S(131, 260), S(135, 258)
    },
    {
        S(217, 580), S(201, 590), S(209, 599), S(233, 588), S(222, 591), S(245, 575), S(249, 568), S(258, 558),
        S(228, 555), S(214, 573), S(221, 589), S(203, 612), S(201, 626), S(247, 565), S(255, 555), S(277, 545),
        S(245, 542), S(241, 554), S(240, 572), S(242, 572), S(250, 571), S(262, 573), S(277, 547), S(275, 544),
        S(237, 561), S(233, 572), S(234, 574), S(230, 588), S(229, 591), S(236, 582), S(243, 574), S(253, 558),
        S(257, 551), S(233, 570), S(243, 572), S(248, 582), S(243, 577), S(250, 562), S(250, 561), S(267, 545),
        S(263, 537), S(267, 543), S(264, 552), S(262, 552), S(264, 545), S(271, 541), S(276, 527), S(273, 528),
        S(265, 537), S(274, 524), S(284, 517), S(280, 524), S(281, 522), S(275, 510), S(282, 488), S(284, 495),
        S(269, 530), S(263, 527), S(270, 522), S(281, 517), S(271, 518), S(253, 516), S(257, 516), S(267, 516)
    },
    {
        S(6, -48), S(14, -20), S(7, -7), S(-79, 24), S(-82, 35), S(-37, 31), S(1, 21), S(41, -21),
        S(-37, -14), S(-3, 2), S(-13, 22), S(33, 22), S(-19, 49), S(-36, 48), S(21, 30), S(6, 12),
        S(-48, -14), S(56, -7), S(-1, 21), S(-20, 37), S(-8, 52), S(14, 41), S(33, 22), S(-37, 9),
        S(-40, -22), S(-14, 1), S(-22, 22), S(-53, 43), S(-79, 67), S(-56, 53), S(-51, 32), S(-89, 18),
        S(-61, -19), S(-25, 0), S(-39, 20), S(-63, 37), S(-71, 61), S(-43, 45), S(-43, 30), S(-92, 22),
        S(-20, -26), S(9, -10), S(-13, 8), S(-20, 15), S(-22, 40), S(-14, 32), S(-5, 19), S(-35, 9),
        S(14, -36), S(18, -21), S(9, -9), S(-4, -3), S(-13, 23), S(-2, 16), S(20, 2), S(6, -8),
        S(4, -57), S(31, -46), S(24, -36), S(-23, -21), S(3, -9), S(-19, 0), S(20, -18), S(4, -37)
    },
};


const int32_t mobilities[5][28] = {

    {
        S(0, 0), S(0, 0), S(91, 182), S(114, 180), S(129, 212), S(0, 0), S(162, 219), S(0, 0), S(138, 190), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0),
    },
    {
        S(0, 0), S(117, 152), S(116, 153), S(118, 171), S(127, 178), S(131, 184), S(137, 192), S(139, 195), S(143, 200), S(143, 201), S(146, 202), S(144, 197), S(142, 194), S(145, 191), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0),
    },
    {
        S(0, 0), S(0, 0), S(159, 296), S(163, 306), S(166, 310), S(168, 316), S(167, 318), S(166, 321), S(168, 322), S(170, 323), S(170, 326), S(169, 330), S(168, 333), S(168, 336), S(163, 337), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0),
    },
    {
        S(0, 0), S(0, 0), S(0, 0), S(352, 359), S(358, 448), S(356, 514), S(362, 509), S(359, 556), S(359, 569), S(358, 581), S(357, 591), S(355, 603), S(354, 611), S(354, 617), S(353, 622), S(351, 630), S(350, 634), S(349, 636), S(346, 642), S(345, 645), S(341, 652), S(342, 653), S(341, 652), S(341, 653), S(346, 647), S(353, 647), S(362, 635), S(379, 631),
    },
    {
        S(0, 0), S(0, 0), S(0, 0), S(33, 10), S(41, 0), S(30, 9), S(22, 3), S(17, 0), S(14, 0), S(11, -2), S(9, -2), S(3, 1), S(0, 1), S(-5, 2), S(-10, 2), S(-19, 3), S(-29, 3), S(-39, 2), S(-51, 3), S(-58, 1), S(-63, -1), S(-68, -3), S(-66, -6), S(-65, -11), S(-69, -14), S(-58, -23), S(-88, -22), S(-53, -38),
    },
};


const int32_t bishop_pair = S(17, 53);


const int32_t passed_pawns[64] = {
    S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0),
    S(30, 176), S(44, 193), S(52, 175), S(58, 140), S(64, 113), S(58, 121), S(31, 148), S(22, 154),
    S(14, 148), S(25, 140), S(6, 115), S(0, 75), S(6, 75), S(11, 94), S(-24, 111), S(-34, 149),
    S(3, 88), S(13, 80), S(12, 60), S(13, 43), S(6, 40), S(11, 52), S(0, 71), S(-19, 91),
    S(4, 51), S(0, 44), S(-4, 29), S(-1, 20), S(-3, 17), S(5, 22), S(6, 36), S(-2, 52),
    S(-3, 14), S(-10, 15), S(-14, 9), S(-14, 6), S(-6, 2), S(0, -2), S(15, 8), S(10, 9),
    S(-9, 8), S(-4, 8), S(-12, 6), S(-13, 6), S(0, -12), S(5, -7), S(21, -3), S(7, 3),
    S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0)
};

const int32_t inner_king_zone_attacks[4] = {
    S(4, -7), S(10, -4), S(10, -4), S(7, 5),
};


const int32_t outer_king_zone_attacks[4] = {
    S(0, 0), S(0, 0), S(2, -2), S(1, 0),
};


const int32_t doubled_pawn_penalty[8] = {
    S(-4, -31), S(-5, -25), S(-10, -19), S(-6, -11), S(-6, -18), S(-11, -16), S(-7, -22), S(-9, -30),
};


const int32_t pawn_storm[64] = {
    S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0),
    S(26, -65), S(2, -71), S(1, -95), S(-6, -50), S(-47, 50), S(-44, -2), S(-7, -31), S(-28, -3),
    S(5, -40), S(-10, -44), S(17, -58), S(-5, -28), S(-12, 22), S(-22, 1), S(-36, -11), S(-38, 0),
    S(-20, -13), S(-24, -15), S(-17, -15), S(-3, -11), S(-7, 12), S(-15, 2), S(-28, 6), S(-34, 9),
    S(-24, -6), S(-22, -5), S(-19, -2), S(-9, -3), S(-2, 5), S(-18, 4), S(-24, 5), S(-31, 10),
    S(-37, 1), S(-41, 3), S(-19, -1), S(4, -4), S(-8, 0), S(-17, 1), S(-48, 12), S(-47, 17),
    S(-32, 5), S(-50, 5), S(-39, 5), S(-16, 0), S(-19, -1), S(-32, 7), S(-60, 19), S(-45, 28),
    S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0)
};

const int32_t isolated_pawns[64] = {
    S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0),
    S(38, -13), S(77, -76), S(26, 6), S(36, 4), S(-5, 22), S(-17, 33), S(-12, 28), S(4, -4),
    S(9, -9), S(5, -43), S(1, -4), S(0, 5), S(-3, 3), S(-9, 2), S(1, -7), S(9, -15),
    S(8, -6), S(0, -23), S(-7, -11), S(-6, -13), S(-6, -18), S(0, -10), S(5, -17), S(7, -4),
    S(2, 2), S(-1, -12), S(-13, -8), S(-17, -20), S(-9, -19), S(-10, -6), S(-11, -7), S(-1, 3),
    S(-7, -2), S(-10, -15), S(-21, -11), S(-18, -14), S(-27, -16), S(-20, -9), S(-20, -14), S(-15, 1),
    S(-4, -3), S(-14, -9), S(-4, -11), S(-25, -6), S(-25, -10), S(-9, -4), S(-5, -14), S(-10, 4),
    S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0), S(0, 0)
};

const int32_t threats[6][6] = {

    {
        S(13, -12), S(3, -43), S(23, -30), S(-33, -25), S(-31, -48), S(-96, 0),
    },
    {
        S(-7, 1), S(0, 0), S(17, 17), S(40, -3), S(14, -49), S(0, 0),
    },
    {
        S(-4, 3), S(13, 17), S(0, 0), S(23, 0), S(25, 42), S(0, 0),
    },
    {
        S(-10, 10), S(3, 5), S(10, 6), S(0, 0), S(35, -9), S(0, 0),
    },
    {
        S(-1, 0), S(0, 4), S(-2, 15), S(6, -15), S(0, 0), S(0, 0),
    },
    {
        S(23, 35), S(-21, 9), S(-14, 12), S(-7, 0), S(0, 0), S(0, 0),
    },
};


const int32_t rook_semi_open[2] = {
    S(21, 6), S(50, 1),
};


const int32_t phalanx_pawns[8] = {
    S(0, 0), S(0, -7), S(0, -5), S(14, 8), S(30, 32), S(84, 90), S(-61, 352), S(0, 0),
};

// For a tapered evaluation
const int32_t game_phase_increment[6] = {
  0, 1, 1, 2, 4, 0
};

// This is our HCE evaluation function. 
int32_t evaluate(const chess::Board& board) {

    int32_t eval_array[2] = {0,0};
    int32_t phase = 0;

    // Get all piece bitboards for efficient looping
    chess::Bitboard wp = board.pieces(chess::PieceType::PAWN, chess::Color::WHITE);
    chess::Bitboard wn = board.pieces(chess::PieceType::KNIGHT, chess::Color::WHITE);
    chess::Bitboard wb = board.pieces(chess::PieceType::BISHOP, chess::Color::WHITE);
    chess::Bitboard wr = board.pieces(chess::PieceType::ROOK, chess::Color::WHITE);
    chess::Bitboard wq = board.pieces(chess::PieceType::QUEEN, chess::Color::WHITE);
    chess::Bitboard wk = board.pieces(chess::PieceType::KING, chess::Color::WHITE);
    chess::Bitboard bp = board.pieces(chess::PieceType::PAWN, chess::Color::BLACK);
    chess::Bitboard bn = board.pieces(chess::PieceType::KNIGHT, chess::Color::BLACK);
    chess::Bitboard bb = board.pieces(chess::PieceType::BISHOP, chess::Color::BLACK);
    chess::Bitboard br = board.pieces(chess::PieceType::ROOK, chess::Color::BLACK);
    chess::Bitboard bq = board.pieces(chess::PieceType::QUEEN, chess::Color::BLACK);
    chess::Bitboard bk = board.pieces(chess::PieceType::KING, chess::Color::BLACK);
    chess::Bitboard all[] = {wp,wn,wb,wr,wq,wk,bp,bn,bb,br,bq,bk};

    int32_t whiteKingSq = board.kingSq(chess::Color::WHITE).index();
    int32_t blackKingSq = board.kingSq(chess::Color::BLACK).index();

    uint64_t not_kingside_w_mask = NOT_KINGSIDE_HALF_MASK[whiteKingSq];
    uint64_t not_kingside_b_mask = NOT_KINGSIDE_HALF_MASK[blackKingSq];

    uint64_t white_king_2_sq_mask = OUTER_2_SQ_RING_MASK[whiteKingSq];
    uint64_t black_king_2_sq_mask = OUTER_2_SQ_RING_MASK[blackKingSq];
    uint64_t white_king_inner_sq_mask = chess::attacks::king(whiteKingSq).getBits();
    uint64_t black_king_inner_sq_mask = chess::attacks::king(blackKingSq).getBits();

    // Rooks on semi open files
    int32_t num_w_rooks_on_semi_op_file = 0;
    int32_t num_b_rooks_on_semi_op_file = 0;

    // A fast way of getting all the pieces 
    for (int32_t i = 0; i < 12; i++){        
        chess::Bitboard curr_bb = all[i];
        while (!curr_bb.empty()) {
            int32_t sq = curr_bb.pop();
            bool is_white = i < 6;
            int32_t j = is_white ? i : i-6;

            // Phase for tapered evaluation
            phase += game_phase_increment[j];

            // Piece square tables
            eval_array[is_white ? 0 : 1] += PSQT[j][is_white ? sq ^ 56 : sq];

            uint64_t attacks_bb = 0ull;

            // Mobilities for knight - queen, and king virtual mobility
            // King Zone
            if (j > 0){
                int32_t attacks = 0;
                switch (j)
                {
                    // knights
                    case 1:
                        attacks_bb = chess::attacks::knight(static_cast<chess::Square>(sq)).getBits();
                        attacks = __builtin_popcountll(attacks_bb);
                        break;
                    // bishops
                    case 2:
                        attacks_bb = chess::attacks::bishop(static_cast<chess::Square>(sq), board.occ()).getBits();
                        attacks = __builtin_popcountll(attacks_bb);
                        break;
                    // rooks
                    case 3:
                        // Rook on semi-open file
                        if ((is_white ? (WHITE_AHEAD_MASK[sq] & wp) : (BLACK_AHEAD_MASK[sq] & bp)) == 0ull){
                            if (is_white) num_w_rooks_on_semi_op_file++;
                            else num_b_rooks_on_semi_op_file++;
                        }

                        attacks_bb = chess::attacks::rook(static_cast<chess::Square>(sq), board.occ()).getBits();
                        attacks = __builtin_popcountll(attacks_bb);
                        break;
                    // queens
                    case 4:
                        attacks_bb = chess::attacks::queen(static_cast<chess::Square>(sq), board.occ()).getBits();
                        attacks = __builtin_popcountll(attacks_bb);
                        break;
                    // King Virtual Mobility
                    case 5:
                        attacks = chess::attacks::queen(static_cast<chess::Square>(sq), board.occ()).count();
                        break;

                    default:
                        break;
                }

                // Mobilities
                eval_array[is_white ? 0 : 1] += mobilities[j-1][attacks];
                
                // Non king non pawn pieces
                if (j < 5){
                    
                    // King zone attacks
                    eval_array[is_white ? 0 : 1] += inner_king_zone_attacks[j-1]  * __builtin_popcountll((is_white ? black_king_inner_sq_mask : white_king_inner_sq_mask) & attacks_bb); 
                    eval_array[is_white ? 0 : 1] += outer_king_zone_attacks[j-1]  * __builtin_popcountll((is_white ? black_king_2_sq_mask : white_king_2_sq_mask) & attacks_bb); 
                }
            }

            // Pawns
            else {
                // Doubled pawns
                // Note that for pawns to be considered "doubled", they need not be directly in front
                // of another pawn
                uint64_t front_mask = is_white ? WHITE_AHEAD_MASK[sq] : BLACK_AHEAD_MASK[sq];
                uint64_t our_pawn_bb = is_white ? wp.getBits() : bp.getBits();
                if (front_mask & our_pawn_bb){
                    eval_array[is_white ? 0 : 1] += doubled_pawn_penalty[is_white ? 7 - sq % 8 : sq % 8];
                }

                // Passed pawn
                if (is_white ? is_white_passed_pawn(sq, bp.getBits()): is_black_passed_pawn(sq, wp.getBits())){
                    eval_array[is_white ? 0 : 1] += passed_pawns[is_white ? sq ^ 56 : sq];
                }

                // Pawn storm
                if (is_white ? (not_kingside_w_mask & (1ull << sq)) : (not_kingside_b_mask & (1ull << sq))){
                    eval_array[is_white ? 0 : 1] += pawn_storm[is_white ? sq ^ 56 : sq];
                }

                // Isolated pawn
                if ((LEFT_RIGHT_COLUMN_MASK[sq] & (is_white ? wp.getBits() : bp.getBits())) == 0ull){
                    eval_array[is_white ? 0 : 1] += isolated_pawns[is_white ? sq ^ 56 : sq];
                }

                // Phalanx pawns
                if (is_white ? (WHITE_LEFT_MASK[sq] & wp) : (BLACK_LEFT_MASK[sq] & bp)){
                    eval_array[is_white ? 0 : 1] += phalanx_pawns[is_white ? sq / 8 : 7 - sq / 8];
                }
            }

            // Actual king attacks because we let attacks bb for king be a queen attacks bb
            // for virtual mobility above
            if (j == 5) attacks_bb = chess::attacks::king(static_cast<chess::Square>(sq)).getBits();

            // Threats
            int32_t num_pawn_attacks = is_white ? __builtin_popcountll(attacks_bb & bp.getBits()) : __builtin_popcountll(attacks_bb & wp.getBits());
            int32_t num_knight_attacks = is_white ? __builtin_popcountll(attacks_bb & bn.getBits()) : __builtin_popcountll(attacks_bb & wn.getBits());
            int32_t num_bishop_attacks = is_white ? __builtin_popcountll(attacks_bb & bb.getBits()) : __builtin_popcountll(attacks_bb & wb.getBits());
            int32_t num_rook_attacks = is_white ? __builtin_popcountll(attacks_bb & br.getBits()) : __builtin_popcountll(attacks_bb & wr.getBits());
            int32_t num_queen_attacks = is_white ? __builtin_popcountll(attacks_bb & bq.getBits()) : __builtin_popcountll(attacks_bb & wq.getBits());
            int32_t num_king_attacks = is_white ? __builtin_popcountll(attacks_bb & bk.getBits()) : __builtin_popcountll(attacks_bb & wk.getBits());

            eval_array[is_white ? 0 : 1] += threats[j][0] * num_pawn_attacks;
            eval_array[is_white ? 0 : 1] += threats[j][1] * num_knight_attacks;
            eval_array[is_white ? 0 : 1] += threats[j][2] * num_bishop_attacks;
            eval_array[is_white ? 0 : 1] += threats[j][3] * num_rook_attacks;
            eval_array[is_white ? 0 : 1] += threats[j][4] * num_queen_attacks;
            eval_array[is_white ? 0 : 1] += threats[j][5] * num_king_attacks;

        }

    }

    // Bishop Pair
    if (wb.count() == 2) eval_array[0] += bishop_pair; 
    if (bb.count() == 2) eval_array[1] += bishop_pair; 

    // Rooks on semi-open files
    if (num_w_rooks_on_semi_op_file == 1) eval_array[0] += rook_semi_open[0];
    if (num_w_rooks_on_semi_op_file == 2) eval_array[0] += rook_semi_open[1];
    if (num_b_rooks_on_semi_op_file == 1) eval_array[1] += rook_semi_open[0];
    if (num_b_rooks_on_semi_op_file == 2) eval_array[1] += rook_semi_open[1];


    int32_t stm = board.sideToMove() == Color::WHITE ? 0 : 1;
    int32_t score = eval_array[stm] - eval_array[stm^1];
    int32_t mg_score = (int32_t)unpack_mg(score);
    int32_t eg_score = (int32_t)unpack_eg(score);
    int32_t mg_phase = phase;
    if (mg_phase > 24) mg_phase = 24;
    int32_t eg_phase = 24 - mg_phase; 

    // Evaluation tapering, that is, interpolating mg and eg values depending on how many pieces
    // there are on the board. See here for more information: https://www.chessprogramming.org/Tapered_Eval
    return tempo.current + ((mg_score * mg_phase + eg_score * eg_phase) / 24);
}
